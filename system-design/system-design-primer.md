# 如何处理一个系统设计的面试题

1. 描述使用场景和约束
2. 创造一个高层级的设计架构
3. 设计核心组件的具体实现
4. 扩展设计（负载均衡、水平扩展、缓存、数据库分片等等）
5. 预估计算量

# 可扩展性

- 性能与可扩展性
- 延迟与吞吐量
- 可用性与一致性

# 可用性与一致性

CAP理论

- Consistency 一致性 - 每次访问都能获得最新数据，但可能会收到错误响应
- Available   可用性 - 每次访问都能获得正常响应，但不保证是最新数据
- Partition Tolerance 分区容错性 - 在任意分区网络故障的情况下，系统仍能继续运行

由于网络不可靠，所以需要支持分区容错性，在一致性和可用性之间取舍。

## CP - 一致性与分区容错性

需要原子读写操作，不能容忍非最新数据。

## AP - 可用性与分区容错性

允许最终一致性，外部故障系统依旧可以继续运行。

# 一致性模式

- 弱一致性 - 写入数据后，访问可能看到，也可能看不到。比如VoIP、视频聊天等。
- 最终一致性 - 写入数据后，访问最终能看到数据（通常是毫秒级时间）。数据被异步复制。
- 强一致性 - 写入数据后，访问立即可见。数据被同步复制。

# 可用性模式

两种模式：**故障切换（fail-over）** 和 **复制（replication）**

## 故障切换

- 工作到备用切换
- 双工作切换

## 复制

- 主-从复制
- 主-主复制

# 域名系统DNS

1. 根DNS服务器
2. 顶级DNS服务器（Top-Level-Domain）
3. 权威DNS服务器
4. ISP供应商DNS服务器

DNS记录(NAME, VALUE, TYPE, TTL)

- A类型 (relay1.bar.foo.com, 123.45.67.89, A) - 指定域名对应的 IP 地址记录。
- NS类型(foo.com, dns.foo.com, NS) - 指定解析域名或子域名的 DNS 服务器。
- CNAME类型(foo.com, relay1.bar.foo.com, CNAME) - 一个域名映射到另一个域名或 CNAME 记录 或 A记录
- MX类型(foo.com, mail.bar.foo.com, MX) - 指定接收信息的邮件服务器

DNS服务器路由流量

- 加权轮询
- 基于延迟路由
- 基于地理位置路由

# 内容分发网络CDN

全球性的代理服务器分布式网络，从靠近用户的位置提供内容。

- 从靠近用户的数据中心提供资源
- 通过 CDN 直接返回，降低服务器的处理请求数

## CDN 推送 （push）

当你服务器上内容发生变动时，推送 CDN 接受新内容。

## CDN 拉取 （pull）

当第一个用户请求该资源时，从服务器上拉取资源，资源缓存到CDN服务器上。

## CDN缺陷

- 流量成本
- TTL过期时间之前，CDN上内容不是最新的
- 资源地址需要指向CDN，迁移成本

# 负载均衡器

Client->Dispatcher->Worker Pool

- 随机
- 轮询 / 加权轮询
- 最少负载
- Session / Cookie
- 请求参数

OSI七层模型

- 应用层（HTTP/SMTP/FTP）
- 表示层（JPEG/ASCII/GIF）
- 会话层（RPC/SQL/NFS）
- 传输层（TCP/UDP）
- 网络层（IP/NAT/ICMP/IPV6/路由选择）
- 链路层（MAC/DOCSIS/ARP/PPP/WiFi）
- 物理层（电缆/光纤/无线信道）

## 第四层负载均衡

通过传输层中的信息来调度，包含来源，目标 IP 地址和请求头中的端口。通过NAT（Network Address Translate）网络地址转换实现。

## 第七层负载均衡

通过请求头的内容，消息和 cookie，更加细粒度的负载。

第四次损失了灵活性，花费更少资源与时间，但是几乎可以忽略不急。

##　水平扩展

- 负载均衡方便进行水平扩展，比在单台硬件上垂直扩展更贵的硬件具有更高的可用性。
- 引入了复杂度，涉及了服务器之间的数据复制（session等）

## 缺陷：负载均衡器

- 如果自身资源配置不够，会成为系统瓶颈
- 消除后端的单点故障，但引入额外的复杂性
- 单个负载均衡导致单点故障，多个负载均衡进一步增加复杂性

# 反向代理（Web服务器）

- 增加安全性 - 隐藏后端服务器,限制连接,IP黑名单等
- 灵活可扩展 - 客户端只能看到反向代理服务器的IP,后端很灵活
- SSL统一处理 - 后端无需关心
- 压缩 - 服务器响应压缩，降低流量
- 缓存 - 可以直接返回缓存的结果
- 静态内容 - 可以代理静态内容

Nginx / HAProxy 同时支持反向代理与负载均衡

# 数据库

- 主从复制：主节点读取/写入，从节点读取
- 主主复制：两个主节点读取/写入，互相复制

## 分片

- 减少读取和写入流量
- 减少复制并提高缓存命中率
- 减少了索引，查询更快

## 缺陷：分片

- 一致性哈希分片
- 修改查询逻辑 / 引入查询中间件

## SQL调优

- 基准测试
- 性能分析（explain、慢查询日志等）
- CHAR类型代替VARCHAR类型
- TEXT类型存储大块文本
- INT类型存储大数字
- DECIMAL类型浮点数
- 避免BLOB存储实际内容，而是存储对象位置
- NOT NULL约束提高搜索性能
- 使用正确的索引
- 冗余数据，避免高成本的JOIN操作
- 分割热点数据
- 优化SQL查询缓存

## NoSQL

包括键-值数据库、文档型数据库、列型数据库、图数据库等，使用BASE理论。

- Basically Available - 基本可用 - 系统保证可用性
- Soft State - 软状态 - 即时没有输入，系统状态可能根据时间变化。也就是存在中间状态，比如副本异步复制。
- Eventual Consistency - 最终一致性 - 经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。

### 键-值

抽象模型：哈希表，O(1)时间读取

- Redis
- Memcached

### 文档类型

抽象模型：将文档作为值的键-值存储

- MongoDB
- CouchDB
- Elastic Search

### 列型

抽象模型：嵌套的 ColumnFamily<RowKey, Columns<ColKey, Value, Timestamp>> 映射

- BigTable
- HBase
- Cassandra

### 图数据库

抽象模型： 图

- Neo4j
- FlockDB

## NoSQL场景

- 埋点数据和日志数据
- 排行榜或者得分数据
- 临时数据，如购物车
- 频繁访问的“热”表
- 元数据／查找表

# 缓存

1. 直写模式

- 应用向缓存中添加/更新数据
- 缓存同步地写入数据存储
- 缓存返回所需内容

2. 回写模式

- 在缓存中增加或者更新条目
- 异步写入数据，提高写入性能

3. 刷新

- 缓存到期之前自动刷新最近访问过的内容

# 异步

- 消息队列
- 任务队列
- 背压(限制队列大小，排满返回降级响应)

# 通讯

- TCP
- UDP
- RPC
- REST

# 安全

- SQL注入
- XSS注入