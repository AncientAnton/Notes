# 算法

Algorithms, Part I 创建者 普林斯顿大学 Week I

## Union-Find

并查集算法 - 查找连通分量

```
public interface UF {

    // 连通两个元素
    void union(int p, int q);

    // 判断两个元素是否在同一个连通分量内
    boolean connected(int p, int q);

    // 查找连通分量中元素个数
    int find(int p);

    /返回并查集中元素的个数
    int count();
}

```

### quick-find

快速查找

1. 使用一维数组标记N个元素
2. 在同一个连通分量中的元素拥有一样的标记
3. 连通两个元素，（两个连通分量合并）

算法效率

1. 初始化  O(N)
2. 连通   O(N)
3. 查找   O(1)

### quick-union

快速合并

1. 假设每个元素为一个节点
2. 元素被标记为指向父节点
3. 连通时，只需要将一个连通分量的根节点，指向另一个分量的根节点
4. 查找时，需要检查两个元素是否指向同一个根节点

算法效率

1. 初始化  O(N)
2. 连通   O(N)
3. 查找   O(N)

### weighted quick-union

快速合并 - 加权

1. 假设每个元素为一个节点
2. 元素被标记为指向父节点
3. 连通时，只需要将一个连通分量的根节点，指向另一个分量的根节点（保证小的树在大的树下方）
4. 查找时，需要检查两个元素是否指向同一个根节点

算法效率

1. 初始化  O(N)
2. 连通   O(lg N)
3. 查找   O(lg N)

进一步优化：压缩路径，在查找root时，将树展平

## Analysis Of Algorithms

算法的分析

1. 可预知的性能表现
2. 不同算法之间的比较
3. 提供算法的依据
4. 理解算法的基础理论
5. 避免性能Bug

分析的步骤

1. 观察特征
2. 构造模型
3. 预测事件
4. 证实预测
5. 重复验证

### observations

1. 执行时间（不同数据量）
2. 硬件环境（CPU、内存、缓存）
3. 软件环境（编译器、解释器、垃圾回收器）
4. 外部系统（OS、网络、其它应用）

### mathematical models

1. 流程分析
2. 计算时间复杂度

### order-of-growth classifications

归类增长顺序（常量、线性、指数）

### theory of algorithms

找出算法的上限与下限，在最差的情况之下，找到最优的解

### applications

无处不在的应用场景